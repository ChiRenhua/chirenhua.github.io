<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[WWDC 2017笔记—Drag and Drop]]></title>
      <url>https://chirenhua.github.io/2017/07/19/WWDC-2017%E7%AC%94%E8%AE%B0%E2%80%94Drag-and-Drop/</url>
      <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/2017%20WWDC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Drag%20and%20Drop/Drag%20and%20Drop%20Logo.png" alt="Drag and Drop Logo">  </p>
<h1 id="Drag-and-Drop"><a href="#Drag-and-Drop" class="headerlink" title="Drag and Drop"></a>Drag and Drop</h1><p>&emsp;&emsp;今年的WWDC，苹果推出了一个新的功能—Drag and Drop，通过这个功能，用户可以将数据（一张图片或者一段文字）从一个地方拖拽到另一个地方，这个操作可以在同一个APP里，也可以跨APP，非常方便。但是目前只有iPad能够完美支持，iPhone上暂时还不支持跨应用的拖拽，所有操作都被限制在同一个APP内。<br>&emsp;&emsp;看名字可以知道，Drag and Drop主要分为两部分，这两部分是相对独立的，APP可以只实现Drag或者只实现Drop，可以了两者都实现。那么接下我会分别介绍Drag、Drop以及在TableView和CollectionView下Drag and Drop实现上的差异。  </p>
<h2 id="一-Drag"><a href="#一-Drag" class="headerlink" title="一. Drag"></a>一. Drag</h2><p>&emsp;&emsp;Drag and Drop的整个流程是基于用户与View之间的交互。我们知道，如果想要为一个View添加点击事件，需要为View添加一个UITapGestureRecognizer。与之类似，如果想要让View支持Drag，需要为View添加UIDragInteraction。那么这个UIDragInteraction是什么？  </p>
<p><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/2017%20WWDC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Drag%20and%20Drop/Drag%20and%20Drop%2001.png" alt="Drag and Drop">  </p>
<p>&emsp;&emsp;通过上面这张图我们可以看出，UIDragInteraction其实就是用户和Drag操作之间的中介，我们可以通过实现其代理方法，为Drag提供数据，或者接收整个Drag流程中各种状态的信息。因为UIDragInteraction中集成了手势，所以在实现Drag的过程中需要打开View的userInteractionEnabled属性。<br>&emsp;&emsp;下面这段代码展示了如何为一个imageView添加UIDragInteraction：  </p>
<p><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/2017%20WWDC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Drag%20and%20Drop/Drag%20and%20Drop%2002.png" alt="Drag and Drop">  </p>
<p>&emsp;&emsp;现在这个imageView已经可以支持Drag了，但是这并不表明它可以相应Drag，因为还没有实现相应的代理方法。下面我会列出所有的代理方法，分别说明都是做什么的。  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">UIDragItem</span> *&gt; *)dragInteraction:(<span class="built_in">UIDragInteraction</span> *)interaction itemsForBeginningSession:(<span class="keyword">id</span>&lt;<span class="built_in">UIDragSession</span>&gt;)session;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个是Drag里最重要的一个方法，这个方法会为Drag提供数据，如果返回nil，那么Drag会被终止掉。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UITargetedDragPreview</span> *)dragInteraction:(<span class="built_in">UIDragInteraction</span> *)interaction previewForLiftingItem:(<span class="built_in">UIDragItem</span> *)item session:(<span class="keyword">id</span>&lt;<span class="built_in">UIDragSession</span>&gt;)session;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;在Drag执行过程中，我们会看到一个View被我们拖着走，这个View是可以通过此方法进行替换的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dragInteraction:(<span class="built_in">UIDragInteraction</span> *)interaction willAnimateLiftWithAnimator:(<span class="keyword">id</span>&lt;<span class="built_in">UIDragAnimating</span>&gt;)animator session:(<span class="keyword">id</span>&lt;<span class="built_in">UIDragSession</span>&gt;)session;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;在触发Drag时，我们需要长按View，此时我们会看到View有一个抬起的状态，在这个抬起的动画将要执行时，会触发此方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dragInteraction:(<span class="built_in">UIDragInteraction</span> *)interaction sessionWillBegin:(<span class="keyword">id</span>&lt;<span class="built_in">UIDragSession</span>&gt;)session;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;Drag已经被触发，准备开始拖动View的时候会触发此方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)dragInteraction:(<span class="built_in">UIDragInteraction</span> *)interaction sessionAllowsMoveOperation:(<span class="keyword">id</span>&lt;<span class="built_in">UIDragSession</span>&gt;)session;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;是否允许Drop以Move的方式响应次方法，这个方法只有在同一个APP里进行操作才会生效，因为在不同的APP里Drop只能以copy的方式来响应。这个方法默认返回YES。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)dragInteraction:(<span class="built_in">UIDragInteraction</span> *)interaction sessionIsRestrictedToDraggingApplication:(<span class="keyword">id</span>&lt;<span class="built_in">UIDragSession</span>&gt;)session;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;决定当前的Drag是否受限于只能被当前APP响应，默认返回NO。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)dragInteraction:(<span class="built_in">UIDragInteraction</span> *)interaction prefersFullSizePreviewsForSession:(<span class="keyword">id</span>&lt;<span class="built_in">UIDragSession</span>&gt;)session;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个方法用来告诉Drag是否需要展示全尺寸的预览图，默认返回NO，如果预览图如果太大系统会替我们进行缩放。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dragInteraction:(<span class="built_in">UIDragInteraction</span> *)interaction sessionDidMove:(<span class="keyword">id</span>&lt;<span class="built_in">UIDragSession</span>&gt;)session;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;用户的手指开始移动时会触发此方法，此时可以通过[UIDragSession locationInView:]来获取当前手指的位置。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dragInteraction:(<span class="built_in">UIDragInteraction</span> *)interaction session:(<span class="keyword">id</span>&lt;<span class="built_in">UIDragSession</span>&gt;)session willEndWithOperation:(<span class="built_in">UIDropOperation</span>)operation;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;Drag将要执行完毕时会触发此方法。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dragInteraction:(<span class="built_in">UIDragInteraction</span> *)interaction session:(<span class="keyword">id</span>&lt;<span class="built_in">UIDragSession</span>&gt;)session didEndWithOperation:(<span class="built_in">UIDropOperation</span>)operation;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;Drag已经执行完毕，并且结束动画已经展示完后会触发此方法。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dragInteraction:(<span class="built_in">UIDragInteraction</span> *)interaction sessionDidTransferItems:(<span class="keyword">id</span>&lt;<span class="built_in">UIDragSession</span>&gt;)session;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;Drop端如果以copy或者move来响应当前Drag时，会对数据进行转移，当转移操作完成时会触发此方法。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">UIDragItem</span> *&gt; *)dragInteraction:(<span class="built_in">UIDragInteraction</span> *)interaction itemsForAddingToSession:(<span class="keyword">id</span>&lt;<span class="built_in">UIDragSession</span>&gt;)session withTouchAtPoint:(<span class="built_in">CGPoint</span>)point;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个方法允许用户继续点击View，为现有的Drag添加新的数据。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">UIDragSession</span>&gt;)dragInteraction:(<span class="built_in">UIDragInteraction</span> *)interaction sessionForAddingItems:(<span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;<span class="built_in">UIDragSession</span>&gt;&gt; *)sessions withTouchAtPoint:(<span class="built_in">CGPoint</span>)point;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;因为我们可以一次拖动多个Drag出来，所以这个方法可以决定你选中的数据需要添加到哪个Drag 上。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dragInteraction:(<span class="built_in">UIDragInteraction</span> *)interaction session:(<span class="keyword">id</span>&lt;<span class="built_in">UIDragSession</span>&gt;)session willAddItems:(<span class="built_in">NSArray</span>&lt;<span class="built_in">UIDragItem</span> *&gt; *)items forInteraction:(<span class="built_in">UIDragInteraction</span> *)addingInteraction;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个方法会在你点击View添加新的数据之前触发。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UITargetedDragPreview</span> *)dragInteraction:(<span class="built_in">UIDragInteraction</span> *)interaction previewForCancellingItem:(<span class="built_in">UIDragItem</span> *)item withDefault:(<span class="built_in">UITargetedDragPreview</span> *)defaultPreview;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;当一个Drag操作被取消时，我们可以通过这个方法来更改取消时的View。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dragInteraction:(<span class="built_in">UIDragInteraction</span> *)interaction item:(<span class="built_in">UIDragItem</span> *)item willAnimateCancelWithAnimator:(<span class="keyword">id</span>&lt;<span class="built_in">UIDragAnimating</span>&gt;)animator;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;当一个Drag操作被取消时，会在执行取消动画前触发此方法。 </p>
<h2 id="二-Drop"><a href="#二-Drop" class="headerlink" title="二. Drop"></a>二. Drop</h2><p>&emsp;&emsp;Drop是在手指松开后执行的操作，通过下面的图我们可以发现它的结构跟Drag如出一辙。同样都是为View添加Interaction，然后通过Delegate来管理整个流程。  </p>
<p><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/2017%20WWDC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Drag%20and%20Drop/Drag%20and%20Drop%2003.png" alt="Drag and Drop">  </p>
<p>&emsp;&emsp;先看下Drop的生命周期：  </p>
<p><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/2017%20WWDC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Drag%20and%20Drop/Drag%20and%20Drop%2004.png" alt="Drag and Drop">  </p>
<p>&emsp;&emsp;首先当数据被拖动到Drop的区域时，会通过“canHandleSession”方法询问Drop是否想响应这次Drag，如果Drop对数据不感兴趣或者不打算响应，那么这次Drag会在手指松开的时候被取消掉。如果可以响应会触发“sessionDidEnter”方法通知用户的手指已经拖动到Drop的可响应区域内。<br>&emsp;&emsp;当用户手指在Drop区域移动时会不停的触发“sessionDidUpdate”方法来询问打算通过何种方法响应Drag，如果“sessionDidUpdate”返回的是cancel，那么在松开手指时，此次Drag会被取消掉，如果返回copy或者move，那么在手指松开时会触发“performDrop”方法，这时才开始真正的对数据进行处理。<br>&emsp;&emsp;当用户手指移动到Drop区域外时会触发“sessionDidExit”方法，此时松开手指Drop是无法被响应的，当手指重新移动回Drop区域时会重新触发“sessionDidEnter”方法，继续后面的流程。<br>&emsp;&emsp;接下来我们看下UIDropInteractionDelegate下的所有方法：  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)dropInteraction:(<span class="built_in">UIDropInteraction</span> *)interaction canHandleSession:(<span class="keyword">id</span>&lt;<span class="built_in">UIDropSession</span>&gt;)session;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个方法就是Drop生命周期中的第一步，返回一个BOOL值来说明对传递过来的数据是否感兴趣，如果这个方法没有被实现，那么这个方法默认返回YES。但是返回YES并不代表Drop一定会接受这个数据。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dropInteraction:(<span class="built_in">UIDropInteraction</span> *)interaction sessionDidEnter:(<span class="keyword">id</span>&lt;<span class="built_in">UIDropSession</span>&gt;)session;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;手指移动到Drop的响应区域时会触发此方法。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UIDropProposal</span> *)dropInteraction:(<span class="built_in">UIDropInteraction</span> *)interaction sessionDidUpdate:(<span class="keyword">id</span>&lt;<span class="built_in">UIDropSession</span>&gt;)session;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个方法必须实现，它会在“sessionDidEnter”之后触发，我们需要指定其返回值“UIDropProposal”下的“operation”属性，operation有四个值，分别是：“UIDropOperationCancel”、 “UIDropOperationForbidden”、 “UIDropOperationCopy”、 “UIDropOperationMove”我们可以通过下面的图看到其对应的效果。 </p>
<p><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/2017%20WWDC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Drag%20and%20Drop/Drag%20and%20Drop%2005.png" alt="Drag and Drop">  </p>
<p><strong>· UIDropOperationCancel：</strong>Drag会被取消掉，不会触发后续的“performDrop”方法。<br><strong>· UIDropOperationCopy：</strong>数据会进行拷贝操作，但是一般用于不同APP之间的Drag and Drop，如果用户在当前位置松开手指，会触发“performDrop”方法。<br><strong>· UIDropOperationMove：</strong>只有当“allowsMoveOperation”方法返回YES时，此Operation才会生效，并且按照苹果在注释中的说法，系统并没有对这个Operation赋予特殊的含义，开发者需要自己对数据源进行删除操作，同时在新的位置添加数据，好让数据看起来是移动（Move）了。- -！<br><strong>· UIDropOperationForbidden：</strong>Drag会被取消掉，同时在Drop Session的右上角会有一个禁止的提示，来提醒用户当前Drop在这个位置是被禁止的。具体什么时候返回“Forbidden”由开发者自行判断，比如当一个“String”类型的数据被拖拽到一个“ImageView”里时，就可以返回“Forbidden”。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dropInteraction:(<span class="built_in">UIDropInteraction</span> *)interaction performDrop:(<span class="keyword">id</span>&lt;<span class="built_in">UIDropSession</span>&gt;)session;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;当用户在Drop的响应区域松开手指时会触发此方法，此时才开始真正的处理数据，开发者需要从“session”中通过“loadObjectsOfClass”方法解析出需要的数据，再进行展示。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dropInteraction:(<span class="built_in">UIDropInteraction</span> *)interaction concludeDrop:(<span class="keyword">id</span>&lt;<span class="built_in">UIDropSession</span>&gt;)session;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;这个方法会在Drop执行完成（包括Drop的动画）之后触发，代表Drop操作已经完成。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dropInteraction:(<span class="built_in">UIDropInteraction</span> *)interaction sessionDidExit:(<span class="keyword">id</span>&lt;<span class="built_in">UIDropSession</span>&gt;)session;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;当用户手指移出Drop的响应区域时会触发此方法。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dropInteraction:(<span class="built_in">UIDropInteraction</span> *)interaction sessionDidEnd:(<span class="keyword">id</span>&lt;<span class="built_in">UIDropSession</span>&gt;)session;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;当Drop操作彻底结束时会触发此方法，无论是成功还是失败。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UITargetedDragPreview</span> *)dropInteraction:(<span class="built_in">UIDropInteraction</span> *)interaction previewForDroppingItem:(<span class="built_in">UIDragItem</span> *)item withDefault:(<span class="built_in">UITargetedDragPreview</span> *)defaultPreview;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;当用户松开手指时，并且Drop已经被成功响应，此时会执行一段Drop的动画，这个动画的View是可以通过这个方法替换的。 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dropInteraction:(<span class="built_in">UIDropInteraction</span> *)interaction item:(<span class="built_in">UIDragItem</span> *)item willAnimateDropWithAnimator:(<span class="keyword">id</span>&lt;<span class="built_in">UIDragAnimating</span>&gt;)animator;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;当用户松开手指时，并且Drop已经被成功响应，此时会执行一段Drop的动画，在这个动画将要执行的时候会触发此方法。  </p>
<h2 id="三-Drag-and-Drop-in-TableView-amp-CollectionView"><a href="#三-Drag-and-Drop-in-TableView-amp-CollectionView" class="headerlink" title="三. Drag and Drop in TableView &amp; CollectionView"></a>三. Drag and Drop in TableView &amp; CollectionView</h2><p>&emsp;&emsp;在TableView和CollectionView中，Drag and Drop的使用跟刚才介绍的大致相同，但是多了一些特有的功能，那么接下来就介绍下TableView和CollectionView独有的一些功能。<br><strong>1.DropIntent</strong><br>&emsp;&emsp;DropIntent是Drop过程中在“sessionDidUpdate”方法里跟随“Operation”属性一起返回的一个属性。这个命名很不苹果，看名字根本不知道这个是用来做什么的。其实这个属性是用来确定在用户Drag数据到TableView或者CollectionView中时，cell需要做出什么动作来提示用户。<br>&emsp;&emsp;在TableView中，DropIntent有四个值：<br><strong>· UITableViewDropIntentUnspecified</strong><br><strong>· UITableViewDropIntentInsertAtDestinationIndexPath</strong><br><strong>· UITableViewDropIntentInsertIntoDestinationIndexPath</strong><br><strong>· UITableViewDropIntentAutomatic</strong><br>&emsp;&emsp;“Unspecified”表示当前手指所在的位置是不明确的，系统稍后会决定这个数据该放在哪里。<br>&emsp;&emsp;“InsertAtDestinationIndexPath”在手指移动过程中会在两个cell之间打开一个空隙，提示用户数据将要插入的位置。效果见下图：  </p>
<p><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/2017%20WWDC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Drag%20and%20Drop/Drag%20and%20Drop%2008.gif" alt="Drag and Drop">  </p>
<p>&emsp;&emsp;“InsertIntoDestinationIndexPath”不会在cell间打开间隙，但是会高亮显示当前手指所在的cell，提示用户当前数据会插入到哪个cell里。效果见下图：  </p>
<p><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/2017%20WWDC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Drag%20and%20Drop/Drag%20and%20Drop%2009.gif" alt="Drag and Drop">  </p>
<p>&emsp;&emsp;“Automatic”会在“InsertAtDestinationIndexPath”和“InsertIntoDestinationIndexPath” 间自己进行选择，当手指在两个cell之间时会打开一个空隙，当手指在cell里时会高亮当前cell。效果见下图：  </p>
<p><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/2017%20WWDC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Drag%20and%20Drop/Drag%20and%20Drop%2010.gif" alt="Drag and Drop">  </p>
<p>&emsp;&emsp;在CollectionView中，DropIntent有三个值：<br><strong>· UICollectionViewDropIntentUnspecified</strong><br><strong>· UICollectionViewDropIntentInsertAtDestinationIndexPath</strong><br><strong>· UICollectionViewDropIntentInsertIntoDestinationIndexPath</strong><br>&emsp;&emsp;CollectionView和TableView的唯一区别就在于CollectionView没有“Automatic”这个效果，其余效果参考TableView。</p>
<p><strong>2.DropPlaceholder</strong><br>&emsp;&emsp;TableView和CollectionView另外一个特有的功能是Placeholder。当数据过大时，数据的传输需要一定的时间，当这个时间过长时我们需要给用户一个提示，系统默认会给我们展示一个提示，如下图：  </p>
<p><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/2017%20WWDC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Drag%20and%20Drop/Drag%20and%20Drop%2007.png" alt="Drag and Drop">  </p>
<p>&emsp;&emsp;我们可以看出这个提示是以对话框形式展示的，虽然会给出进度但是这个提示太强了，用户此时只能等待，不能操作界面。所以系统给我们提供了其它方法可以替代这个弹框，这个就是Placeholder。在“performDrop”方法里，系统为我们提供了一个参数：DropCoordinator，它就是实现placeHolder的关键，在”loadObjectOfClass”前，我们先调用“DropCoordinator”下面的方法为collectionView插入一个临时的cell： </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">UICollectionViewDropPlaceholderContext</span>&gt;)dropItem:(<span class="built_in">UIDragItem</span> *)dragItem toPlaceholderInsertedAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath withReuseIdentifier:(<span class="built_in">NSString</span> *)reuseIdentifier cellUpdateHandler:(<span class="keyword">void</span> (^)(__kindof <span class="built_in">UICollectionViewCell</span> *))cellUpdateHandler;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;在这个cell上我们可以展示进度条或者一个loadingView。当数据加载完毕后，我们再调用“commitInsertionWithDataSourceUpdates:”方法将数据插入到数据源中，替换临时的cell。效果如下图：  </p>
<p><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/2017%20WWDC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94Drag%20and%20Drop/Drag%20and%20Drop%2006.png" alt="Drag and Drop"></p>
<p>&emsp;&emsp;最后附上Demo：<a href="https://github.com/ChiRenhua/Drag-and-drop" target="_blank" rel="external">Drag and Drop</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Xcode-真机编译iOS7方法]]></title>
      <url>https://chirenhua.github.io/2017/05/15/Xcode-%E7%9C%9F%E6%9C%BA%E7%BC%96%E8%AF%91iOS7%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/Xcode-%E7%9C%9F%E6%9C%BA%E7%BC%96%E8%AF%91iOS7%E6%96%B9%E6%B3%95/ios-7-logo.png" alt="iOS7_Logo">  </p>
<h2 id="真机编译iOS7的方法"><a href="#真机编译iOS7的方法" class="headerlink" title="真机编译iOS7的方法"></a>真机编译iOS7的方法</h2><p>步骤炒鸡简单：   </p>
<ol>
<li>将iOS7.0/iOS7.1的SDK放到Xcode这个目录下(iOS7 SDK请百度自行下载)：<br>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport；</li>
<li>进入目录：<br>/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk  打开“iPhoneOS.sdk”文件夹和“SDKSettings.plist”文件的读写权限；  </li>
<li>打开“SDKSettings.plist”文件，按图添加7.0/7.1（⚠️一定要按照从小到大的顺序添加）然后重启Xcode就可以了。<br><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/Xcode-%E7%9C%9F%E6%9C%BA%E7%BC%96%E8%AF%91iOS7%E6%96%B9%E6%B3%95/iOS7_debug.png" alt="iOS7_Debug"></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS--自定义转场动画]]></title>
      <url>https://chirenhua.github.io/2017/04/22/iOS-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/</url>
      <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/iOS--%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%20/iOS_TranslationAnimate.jpg" alt="TranslateAnimateLogo">  </p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;在iOS7中，苹果爸爸为开发者提供了一套全新的API去实现转场动画，开发者可以通过更灵活的方式去设计动画效果。同时，iOS7还支持用手势切换VC，比如你在某个应用中push了一个新的页面，那么你可以通过在屏幕左侧向右滑动来执行返回操作。</p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>&emsp;&emsp;实现动画的主要API：<br>&emsp;&emsp;1. @protocol UIViewControllerContextTransitioning<br>&emsp;&emsp;2. @protocol UIViewControllerAnimatedTransitioning<br>&emsp;&emsp;3. @protocol UIViewControllerTransitioningDelegate  </p>
<h3 id="UIViewControllerContextTransitioning"><a href="#UIViewControllerContextTransitioning" class="headerlink" title="UIViewControllerContextTransitioning"></a>UIViewControllerContextTransitioning</h3><p>&emsp;&emsp;这个接口在切换VC过程中为我们提供了上下文，通过它我们可以获取到执行切换时，两个VC的详细信息。在实现跳转动画的方法中，系统会为我们提供这个上下文，所以开发者并不需要去实现这个接口。  </p>
<h3 id="UIViewControllerAnimatedTransitioning"><a href="#UIViewControllerAnimatedTransitioning" class="headerlink" title="UIViewControllerAnimatedTransitioning"></a>UIViewControllerAnimatedTransitioning</h3><p>&emsp;&emsp;这个接口是在VC切换过程中起着非常重要的角色，因为它负责处理切换过程中的事件，也就是说我们要实现的动画效果等，都是在这里实现的。这里我们需要实现下面的两个方法。<br>&emsp;&emsp;<code>-(NSTimeInterval)transitionDuration:(id &lt; UIViewControllerContextTransitioning &gt;)transitionContext;</code><br>&emsp;&emsp;返回切换过程所需要的时间。<br>&emsp;&emsp;<code>-(void)animateTransition:(id &lt; UIViewControllerContextTransitioning &gt;)transitionContext;</code><br>&emsp;&emsp;切换时会调用此方法，动画效果都在这个方法里完成。  </p>
<h3 id="UIViewControllerTransitioningDelegate"><a href="#UIViewControllerTransitioningDelegate" class="headerlink" title="UIViewControllerTransitioningDelegate"></a>UIViewControllerTransitioningDelegate</h3><p>&emsp;&emsp;对于想要执行自定义动画的VC需要实现这个接口，共有四个方法。<br>&emsp;&emsp;<code>-(id&lt; UIViewControllerAnimatedTransitioning &gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source;</code><br>&emsp;&emsp;跳转新页面的动画。<br>&emsp;&emsp;<code>-(id&lt; UIViewControllerAnimatedTransitioning &gt;)animationControllerForDismissedController:(UIViewController *)dismissed;</code><br>&emsp;&emsp;当前页面消失的动画。<br>&emsp;&emsp;<code>-(id&lt; UIViewControllerInteractiveTransitioning &gt;)interactionControllerForPresentation:(id &lt; UIViewControllerAnimatedTransitioning &gt;)animator;</code><br>&emsp;&emsp;手势控制页面跳转的动画。<br>&emsp;&emsp;<code>-(id&lt; UIViewControllerInteractiveTransitioning &gt;)interactionControllerForDismissal:(id &lt; UIViewControllerAnimatedTransitioning &gt;)animator;</code><br>&emsp;&emsp;手势控制页面消失的动画。  </p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><p>&emsp;&emsp;我们先来尝试着实现如下图效果的页面切换。<br><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/iOS--%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%20/Untitled.gif" alt="translateAnimate"><br>&emsp;&emsp;首先我们新建一个处理动画效果的类，这个类要实现“UIViewControllerAnimatedTransitioning”接口。<br>TranslationAnimateManager.h    </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, TransitionType) &#123;</div><div class="line">    TransitionTypePresent,</div><div class="line">    TransitionTypeDismiss</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TranslationAnimateManager</span> : <span class="title">NSObject</span> &lt;<span class="title">UIViewControllerAnimatedTransitioning</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">//根据定义的枚举初始化的两个方法</span></div><div class="line">+ (<span class="keyword">instancetype</span>)transitionWithTransitionType:(TransitionType)type;</div><div class="line">- (<span class="keyword">instancetype</span>)initWithTransitionType:(TransitionType)type;</div><div class="line"></div><div class="line"><span class="keyword">@end</span>   </div><div class="line"></div><div class="line">```  </div><div class="line">TranslationAnimateManager.m    </div><div class="line"></div><div class="line">``` objc</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TranslationAnimateManager</span> ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) TransitionType type;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TranslationAnimateManager</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">instancetype</span>)transitionWithTransitionType:(TransitionType)type &#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">id</span> sharedInstance = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        sharedInstance = [[<span class="keyword">self</span> alloc] initWithTransitionType:type];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> sharedInstance;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithTransitionType:(TransitionType)type &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</div><div class="line">        <span class="keyword">self</span>.type = type;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSTimeInterval</span>)transitionDuration:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">0.5</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)animateTransition:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext &#123;</div><div class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.type) &#123;</div><div class="line">        <span class="keyword">case</span> TransitionTypePresent:</div><div class="line">            [<span class="keyword">self</span> presentAnimation:transitionContext];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> TransitionTypeDismiss:</div><div class="line">            [<span class="keyword">self</span> dismissAnimation:transitionContext];</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//实现present动画逻辑代码</span></div><div class="line">- (<span class="keyword">void</span>)presentAnimation:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext&#123;</div><div class="line">    <span class="built_in">UIViewController</span> *fromVC = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextFromViewControllerKey</span>];</div><div class="line">    <span class="built_in">UIViewController</span> *toVC = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextToViewControllerKey</span>];</div><div class="line">    </div><div class="line">    <span class="built_in">UIView</span> *toView = toVC.view;</div><div class="line">    <span class="built_in">UIView</span> *fromView = fromVC.view;</div><div class="line">    <span class="built_in">UIView</span> *containerView = [transitionContext containerView];</div><div class="line">    </div><div class="line">    <span class="built_in">UIView</span> *toViewSnapshot = [<span class="built_in">UIView</span> new];</div><div class="line">    toViewSnapshot.contentImage =  toView.snapshotImage;</div><div class="line">    toViewSnapshot.frame = containerView.bounds;</div><div class="line">    </div><div class="line">    <span class="built_in">CATransform3D</span> scale = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">    toViewSnapshot.layer.transform = <span class="built_in">CATransform3DScale</span>(scale, <span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">1</span>);<span class="comment">//</span></div><div class="line">    [containerView addSubview:toViewSnapshot];</div><div class="line">    [containerView sendSubviewToBack:toViewSnapshot];</div><div class="line">    <span class="built_in">CGRect</span> upSnapshotRegion = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, fromView.frame.size.width, fromView.frame.size.height  * <span class="number">0.5</span>);</div><div class="line">    <span class="built_in">UIView</span> *upHandView = [<span class="built_in">UIView</span> new];</div><div class="line">    upHandView.contentImage = fromView.snapshotImage;</div><div class="line">    upHandView.layer.contentsRect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0.5</span>);</div><div class="line">    upHandView.frame = upSnapshotRegion;</div><div class="line">    [containerView addSubview:upHandView];</div><div class="line">    </div><div class="line">    <span class="built_in">CGRect</span> downSnapshotRegion = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, fromView.frame.size.height * <span class="number">0.5</span>, fromView.frame.size.width, fromView.frame.size.height * <span class="number">0.5</span>);</div><div class="line">    <span class="built_in">UIView</span> *downHandView = [<span class="built_in">UIView</span> new];</div><div class="line">    downHandView.contentImage = upHandView.contentImage;</div><div class="line">    downHandView.layer.contentsRect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>, <span class="number">0.5</span>);</div><div class="line">    downHandView.frame = downSnapshotRegion;</div><div class="line">    [containerView addSubview:downHandView];</div><div class="line">    </div><div class="line">    fromView.hidden = <span class="literal">YES</span>;</div><div class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.5</span></div><div class="line">                          delay:<span class="number">0.0</span></div><div class="line">                        options:<span class="built_in">UIViewAnimationOptionCurveEaseOut</span></div><div class="line">                     animations:^&#123;</div><div class="line">                         upHandView.frame = <span class="built_in">CGRectOffset</span>(upHandView.frame, <span class="number">0</span>, - upHandView.frame.size.height);</div><div class="line">                         downHandView.frame = <span class="built_in">CGRectOffset</span>(downHandView.frame, <span class="number">0</span>, downHandView.frame.size.height);</div><div class="line">                         toViewSnapshot.center = toView.center;</div><div class="line">                         toViewSnapshot.frame = toView.frame;</div><div class="line">                     &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                         fromView.hidden = <span class="literal">NO</span>;</div><div class="line">                         <span class="keyword">if</span> ([transitionContext transitionWasCancelled]) &#123;</div><div class="line">                             [containerView addSubview:fromView];</div><div class="line">                             [<span class="keyword">self</span> removeOtherViews:fromView];</div><div class="line">                         &#125; <span class="keyword">else</span> &#123;</div><div class="line">                             [containerView addSubview:toView];</div><div class="line">                             [<span class="keyword">self</span> removeOtherViews:toView];</div><div class="line">                         &#125;</div><div class="line">                         [transitionContext completeTransition:![transitionContext transitionWasCancelled]];</div><div class="line">                     &#125;];</div><div class="line">&#125;</div><div class="line"><span class="comment">//实现dismiss动画逻辑代码</span></div><div class="line">- (<span class="keyword">void</span>)dismissAnimation:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerContextTransitioning</span>&gt;)transitionContext&#123;</div><div class="line">    <span class="built_in">UIViewController</span> *fromVC = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextFromViewControllerKey</span>];</div><div class="line">    <span class="built_in">UIViewController</span> *toVC = [transitionContext viewControllerForKey:<span class="built_in">UITransitionContextToViewControllerKey</span>];</div><div class="line">    <span class="built_in">UIView</span> *toView = toVC.view;</div><div class="line">    <span class="built_in">UIView</span> *fromView = fromVC.view;</div><div class="line">    <span class="built_in">UIView</span> *containerView = [transitionContext containerView];</div><div class="line">    [containerView addSubview:fromView];</div><div class="line">    toView.frame = [transitionContext finalFrameForViewController:toVC];</div><div class="line">    toView.frame = <span class="built_in">CGRectOffset</span>(toView.frame, toView.frame.size.width, <span class="number">0</span>);</div><div class="line">    [containerView addSubview:toView];</div><div class="line">    <span class="built_in">CGRect</span> upSnapshotRegion = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, fromView.frame.size.width, fromView.frame.size.height * <span class="number">0.5</span>);</div><div class="line">    <span class="built_in">UIView</span> *upHandView = [<span class="built_in">UIView</span> new];</div><div class="line">    upHandView.contentImage = toView.snapshotImage;</div><div class="line">    upHandView.layer.contentsRect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0.5</span>);</div><div class="line">    upHandView.frame = upSnapshotRegion;</div><div class="line">    upHandView.frame = <span class="built_in">CGRectOffset</span>(upHandView.frame, <span class="number">0</span>, - upHandView.frame.size.height);</div><div class="line">    [containerView addSubview:upHandView];</div><div class="line">    <span class="built_in">CGRect</span> downSnapshotRegion = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, fromView.frame.size.height * <span class="number">0.5</span>, fromView.frame.size.width, fromView.frame.size.height * <span class="number">0.5</span>);</div><div class="line">    <span class="built_in">UIView</span> *downHandView = [<span class="built_in">UIView</span> new];</div><div class="line">    downHandView.contentImage = upHandView.contentImage;</div><div class="line">    downHandView.layer.contentsRect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">1</span>, <span class="number">0.5</span>);</div><div class="line">    downHandView.frame = downSnapshotRegion;</div><div class="line">    downHandView.frame = <span class="built_in">CGRectOffset</span>(downHandView.frame, <span class="number">0</span>, downHandView.frame.size.height);</div><div class="line">    [containerView addSubview:downHandView];</div><div class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.5</span></div><div class="line">                          delay:<span class="number">0.0</span></div><div class="line">                        options:<span class="built_in">UIViewAnimationOptionCurveEaseOut</span></div><div class="line">                     animations:^&#123;</div><div class="line">                         upHandView.frame = <span class="built_in">CGRectOffset</span>(upHandView.frame, <span class="number">0</span>, upHandView.frame.size.height);</div><div class="line">                         downHandView.frame = <span class="built_in">CGRectOffset</span>(downHandView.frame, <span class="number">0</span>, - downHandView.frame.size.height);</div><div class="line">                         <span class="built_in">CATransform3D</span> scale = <span class="built_in">CATransform3DIdentity</span>;</div><div class="line">                         fromView.layer.transform = <span class="built_in">CATransform3DScale</span>(scale, <span class="number">0.9</span>, <span class="number">0.9</span>, <span class="number">1</span>);<span class="comment">//</span></div><div class="line">                     &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                         <span class="keyword">if</span> ([transitionContext transitionWasCancelled]) &#123;</div><div class="line">                             [<span class="keyword">self</span> removeOtherViews:fromView];</div><div class="line">                         &#125; <span class="keyword">else</span> &#123;</div><div class="line">                             [<span class="keyword">self</span> removeOtherViews:toView];</div><div class="line">                             toView.frame = containerView.bounds;</div><div class="line">                         &#125;</div><div class="line">                         [transitionContext completeTransition:![transitionContext transitionWasCancelled]];</div><div class="line">                     &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)removeOtherViews:(<span class="built_in">UIView</span>*)viewToKeep &#123;</div><div class="line">    <span class="built_in">UIView</span> *containerView = viewToKeep.superview;</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *view <span class="keyword">in</span> containerView.subviews) &#123;</div><div class="line">        <span class="keyword">if</span> (view != viewToKeep) &#123;</div><div class="line">            [view removeFromSuperview];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后我们再新建一个初始VC，就叫“FromViewController”。这个页面只需要负责点击按钮跳转即可，省下什么都不用做。    </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FromViewController</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) ToViewController *toVC;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FromViewController</span></span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> brownColor];</div><div class="line">    </div><div class="line">    <span class="built_in">UIButton</span> *button = [[<span class="built_in">UIButton</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="keyword">self</span>.view.bounds.size.width / <span class="number">2</span> - <span class="number">50</span>, <span class="keyword">self</span>.view.bounds.size.height / <span class="number">2</span> - <span class="number">15</span>, <span class="number">100</span>, <span class="number">30</span>)];</div><div class="line">    [button setTitle:<span class="string">@"点我跳转"</span> forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">    [button setBackgroundColor:[<span class="built_in">UIColor</span> blackColor]];</div><div class="line">    [button addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(buttonClick) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</div><div class="line">    button.layer.cornerRadius = <span class="number">15</span>;</div><div class="line">    [<span class="keyword">self</span>.view addSubview:button];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)buttonClick &#123;</div><div class="line">    <span class="keyword">self</span>.toVC = [[ToViewController alloc] init];</div><div class="line">    [<span class="keyword">self</span> presentViewController:<span class="keyword">self</span>.toVC animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;接下来我们再创建一个新的页面叫做“ToViewController”，是跳转后的界面，因为要实现自定的跳转动画，所以这个页面要实现“UIViewControllerTransitioningDelegate”接口。  </p>
<pre><code class="objc"><span class="class"><span class="keyword">@interface</span> <span class="title">ToViewController</span> ()&lt;<span class="title">UIViewControllerTransitioningDelegate</span>&gt;</span>

<span class="keyword">@end</span>

<span class="class"><span class="keyword">@implementation</span> <span class="title">ToViewController</span></span>

- (<span class="keyword">id</span>)init {
    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) {
    }
    <span class="keyword">return</span> <span class="keyword">self</span>;
}

- (<span class="keyword">void</span>)viewDidLoad {
    [<span class="keyword">super</span> viewDidLoad];
    <span class="keyword">self</span>.transitioningDelegate = <span class="keyword">self</span>;
    <span class="keyword">self</span>.modalPresentationStyle = <span class="built_in">UIModalPresentationCustom</span>;
    <span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> grayColor];

    <span class="built_in">UIButton</span> *button = [[<span class="built_in">UIButton</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="keyword">self</span>.view.bounds.size.width / <span class="number">2</span> - <span class="number">50</span>, <span class="keyword">self</span>.view.bounds.size.height / <span class="number">2</span> - <span class="number">15</span>, <span class="number">100</span>, <span class="number">30</span>)];
    [button setTitle:<span class="string">@"点我回退"</span> forState:<span class="built_in">UIControlStateNormal</span>];
    [button setBackgroundColor:[<span class="built_in">UIColor</span> blackColor]];
    [button addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(buttonClick) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];
    button.layer.cornerRadius = <span class="number">15</span>;
    [<span class="keyword">self</span>.view addSubview:button];
}

- (<span class="keyword">void</span>)buttonClick {
    [<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];
}

- (<span class="keyword">id</span> &lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForPresentedController:(<span class="built_in">UIViewController</span> *)presented presentingController:(<span class="built_in">UIViewController</span> *)presenting sourceController:(<span class="built_in">UIViewController</span> *)source {
    <span class="keyword">return</span> [TranslationAnimateManager transitionWithTransitionType:TransitionTypePresent];
}

- (<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animationControllerForDismissedController:(<span class="built_in">UIViewController</span> *)dismissed{
    <span class="comment">//这里我们初始化dismissType</span>
    <span class="keyword">return</span> [[TranslationAnimateManager alloc ]initWithTransitionType:TransitionTypeDismiss];
}
</code></pre>
<p>&emsp;&emsp;至此，我们就完成了第一部分自定义跳转动画，赶快运行起来试试吧～  </p>
<h3 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><p>&emsp;&emsp;现在我们点击按钮可以让页面按照我们写好的动画跳转到下一个页面，但是还有一个手势控制我们没有实现，利用手势控制我们可以实现更加友好的界面操作。<br>&emsp;&emsp;我们再创建一个类，继承自“UIPercentDrivenInteractiveTransition”，用来监听我们的手势操作。  </p>
<pre><code class="obj">@interface SwipeInteractiveTransition ()

@property (nonatomic, assign) BOOL shouldComplete;
@property (nonatomic, strong) UIViewController *presentingVC;
@property (nonatomic, strong) UIViewController *targetVC;

@end

@implementation SwipeInteractiveTransition

+ (instancetype)sharedInstance {
    static id sharedInstance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        sharedInstance = [[self alloc] init];
    });
    return sharedInstance;
}

-(void)wireToViewController:(UIViewController *)viewController
{
    self.presentingVC = viewController;
    [self prepareGestureRecognizerInView:viewController.view];
}

- (void)writeTargetViewController:(UIViewController *)viewController {
    self.targetVC = viewController;
}

- (void)prepareGestureRecognizerInView:(UIView*)view {
    UIPanGestureRecognizer *gesture = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(handleGesture:)];
    [view addGestureRecognizer:gesture];
}

-(CGFloat)completionSpeed
{
    return 1 - self.percentComplete;
}

- (void)handleGesture:(UIPanGestureRecognizer *)gestureRecognizer {
    CGPoint translation = [gestureRecognizer translationInView:gestureRecognizer.view.superview];
    switch (gestureRecognizer.state) {
        case UIGestureRecognizerStateBegan: {
            self.interacting = YES;
            self.targetVC = [[ToViewController alloc] init];
            [self.presentingVC presentViewController:self.targetVC animated:YES completion:nil];
        }
            break;
        case UIGestureRecognizerStateChanged: {
            NSInteger y =  translation.y;
            CGFloat fraction = y / 200.0;
            fraction = fminf(fmaxf(fraction, 0.0), 1.0);
            self.shouldComplete = (fraction &gt; 0.1);

            [self updateInteractiveTransition:fraction];
            break;
        }
        case UIGestureRecognizerStateEnded:
        case UIGestureRecognizerStateCancelled: {
            self.interacting = NO;
            if (!self.shouldComplete || gestureRecognizer.state == UIGestureRecognizerStateCancelled) {
                [self cancelInteractiveTransition];
            } else {
                [self finishInteractiveTransition];
            }
            break;
        }
        default:
            break;
    }
}

@end
</code></pre>
<p>&emsp;&emsp;然后在“FromViewController”中，我们添加如下代码注册手势监听：  </p>
<pre><code class="objc"><span class="keyword">self</span>.toVC = [[ToViewController alloc] init];
SwipeInteractiveTransition *swipeInteractiveTransition = [SwipeInteractiveTransition sharedInstance];
[swipeInteractiveTransition wireToViewController:<span class="keyword">self</span>];
[swipeInteractiveTransition writeTargetViewController:<span class="keyword">self</span>.toVC];
</code></pre>
<p>&emsp;&emsp;在“ToViewController”中，我们要实现下面的方法：  </p>
<pre><code class="objc">-(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerInteractiveTransitioning</span>&gt;)interactionControllerForPresentation:(<span class="keyword">id</span>&lt;<span class="built_in">UIViewControllerAnimatedTransitioning</span>&gt;)animator {
    <span class="keyword">return</span> [SwipeInteractiveTransition sharedInstance].interacting ? [SwipeInteractiveTransition sharedInstance] : <span class="literal">nil</span>;
}
</code></pre>
<p>&emsp;&emsp;如果没有手势触发或者手势触发失败，这个方法会返回空，此时系统会自动调用<code>- (id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source</code>这个方法去执行跳转动画。<br>&emsp;&emsp;我们看下完成后的效果。<br><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/iOS--%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%20/Untitled2.gif" alt="translateAnimate2"><br>&emsp;&emsp;看着还是很nice的。其实苹果为我们提供的动画接口还是很强大的，如果利用好了可以做出很多酷炫的效果和新颖的交互。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Instruments--Core Animation下Debug Options的介绍和优化方法]]></title>
      <url>https://chirenhua.github.io/2017/02/12/Instruments-Core-Animation%E4%B8%8BDebug-Options%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BC%98%E5%8C%96%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/Instruments--Core%20Animation下Debug%20Options的介绍和优化方法/Instruments_Logo.png" alt="Instruments_Logo">  </p>
<h2 id="关于视图的优化"><a href="#关于视图的优化" class="headerlink" title="关于视图的优化"></a>关于视图的优化</h2><p>&emsp;&emsp;在开发一个产品的过程中，我们不仅仅要实现功能，其实使用的体验也是很重要的一部分，那么使用过程中非常影响用户体验的就是流畅度，所以如何提高流畅度，避免卡顿是一个必须要重视的问题。好在强大的苹果为开发者提供了一个工具–Instruments，通过它我们可以轻松的找出拖慢我们产品的元凶。<br>&emsp;&emsp;<br>首先打开Instruments，选择Core Animation，然后打开一个目标程序，点击Record，此时Instruments就开始监控你的程序，并且实时展示帧数。在屏幕右下侧部分点击设置按钮，会展开一个页面，上面有Debug Options各个选项，下面介绍各个选项所展示的性能问题和优化方法。<br><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/Instruments--Core%20Animation下Debug%20Options的介绍和优化方法/Instruments_DebugOptions.png" alt="Instruments_01">  </p>
<h2 id="Color-Blended-Layers（混合图层）"><a href="#Color-Blended-Layers（混合图层）" class="headerlink" title="Color Blended Layers（混合图层）"></a>Color Blended Layers（混合图层）</h2><p>&emsp;&emsp;混合图层的概念其实就是多个图层盖在了一起，我们知道屏幕是一个一个像素点组合在一起的，而像素点展示什么颜色是由R、G、B、alpha四个部分组成，所以如果多个图层盖在一起，那么其最终的颜色，会受到每个图层的影响。而在计算最终颜色的过程中，会消耗GPU的资源，所以如果你只想显示最上层图层的颜色，那么可以将它设置为不透明，这样的话GPU会自动忽略下面的所有View，从而减少GPU的压力。  </p>
<h3 id="UILable避免混合图层的办法："><a href="#UILable避免混合图层的办法：" class="headerlink" title="UILable避免混合图层的办法："></a>UILable避免混合图层的办法：</h3><p>&emsp;&emsp;为UILable设置非透明背景色：<br>&emsp;&emsp;<code>lable.backgroundColor = [UIColor whiteColor];</code><br>&emsp;&emsp;如果UILable展示的是中文，设置  &emsp;&emsp;<code>layer.masksToBounds = YES;</code><br>&emsp;&emsp;不要慌，这里不会触发离屏渲染，在iOS8以后，展示中文时，UILable外围会有一圈透明的边，所以才要加这个，看下图）<br><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/Instruments--Core%20Animation下Debug%20Options的介绍和优化方法/Instruments_03.png" alt="Instruments_03"></p>
<h3 id="UIImageVIew避免混合图层的办法："><a href="#UIImageVIew避免混合图层的办法：" class="headerlink" title="UIImageVIew避免混合图层的办法："></a>UIImageVIew避免混合图层的办法：</h3><p>&emsp;&emsp;很简单，只要图片本身没有透明的地方就可以啦，然后代码保证没有设置alpha值一类的属性就没问题。  </p>
<h2 id="Color-Hits-Green-and-Misses-Red-光栅化"><a href="#Color-Hits-Green-and-Misses-Red-光栅化" class="headerlink" title="Color Hits Green and Misses Red (光栅化)"></a>Color Hits Green and Misses Red (光栅化)</h2><p>&emsp;&emsp;如果shouldRasterize被设置成YES，对应的渲染结果会被缓存，如果图层是绿色，就表示这些缓存被复用；如果是红色就表示缓存会被重复创建，这就表示该处存在性能问题了。<br>&emsp;&emsp;所以一般在图像内容不变的情况下才使用光栅化，例如设置阴影耗费资源比较多的静态内容，如果使用光栅化对性能的提升有一定帮助。反之如果图像内容总会变就不要设置这个属性。<br>&emsp;&emsp;如果你在一个界面中使用了光栅化，刚进去这个页面的所有使用了光栅化的控件layer都会是红色，因为还没有缓存成功，如果上下滑动你会发现，layer变成了绿色。但是如果你滑动幅度较大会发现，新出现的控件会是红色然后变成绿色，因为刚开始这些控件的layer还没有缓存。<br>&emsp;&emsp;注意点：<br>&emsp;&emsp;（1）系统给光栅化缓存分配了一个固定的大小，因此不能过度使用，如果超出了缓存也会造成离屏渲染。<br>&emsp;&emsp;（2）缓存的时间为100ms，因此如果在100ms内没有使用缓存的对象，则会从缓存中清除。  </p>
<h2 id="color-copied-images（图片颜色格式）"><a href="#color-copied-images（图片颜色格式）" class="headerlink" title="color copied images（图片颜色格式）"></a>color copied images（图片颜色格式）</h2><p>苹果给出的官网解释：<br>”If an image is in a color format that the GPU can not directly work with, it will be converted in the CPU.”<br>&emsp;&emsp;翻译过来就是：苹果的GPU只解析 32bit 的颜色格式。<br>&emsp;&emsp;如果你放一张图片，而它的颜色格式不是 32bit ，CPU会先进行颜色格式转换，再让GPU渲染。这样无形中就消耗了CPU部分性能。<br>&emsp;&emsp;解决办法：<br>&emsp;&emsp;1. 让设计师给图的时候注意要是32bit的。<br>&emsp;&emsp;2. 再开一个异步线程去处理颜色格式的转换。<br>&emsp;&emsp;（还是第一个办法好）  </p>
<h2 id="Color-Non-Standard-Surface-Formats（颜色非标准表面格式）"><a href="#Color-Non-Standard-Surface-Formats（颜色非标准表面格式）" class="headerlink" title="Color Non-Standard Surface Formats（颜色非标准表面格式）"></a>Color Non-Standard Surface Formats（颜色非标准表面格式）</h2><p>&emsp;&emsp;没查到时嘎哈的，只知道大概跟文本的显示有关。</p>
<h2 id="Color-Immediately（立即执行颜色刷新）"><a href="#Color-Immediately（立即执行颜色刷新）" class="headerlink" title="Color Immediately（立即执行颜色刷新）"></a>Color Immediately（立即执行颜色刷新）</h2><p>&emsp;&emsp;默认的颜色刷新有10ms延迟，这个选项可以去掉这个延迟，某些情况下调试可能会用到。</p>
<h2 id="Color-Misaligned-Images-图片大小不符"><a href="#Color-Misaligned-Images-图片大小不符" class="headerlink" title="Color Misaligned Images(图片大小不符)"></a>Color Misaligned Images(图片大小不符)</h2><p>&emsp;&emsp;当展示的图片和容器的大小不匹配时image会被标黄，尽量用大小符合的图片，不然会消耗资源对图片进行压缩或放大。  </p>
<h2 id="Color-Offscreen-Rendered-Yellow（离屏渲染）"><a href="#Color-Offscreen-Rendered-Yellow（离屏渲染）" class="headerlink" title="Color Offscreen-Rendered Yellow（离屏渲染）"></a>Color Offscreen-Rendered Yellow（离屏渲染）</h2><p>&emsp;&emsp;参考文章：<a href="https://chirenhua.github.io/2016/10/22/iOS-离屏渲染带来的性能问题和解决办法/">iOS-离屏渲染带来的性能问题和解决办法</a></p>
<h2 id="Color-Compositing-Fast-Path-Blue-快速路径"><a href="#Color-Compositing-Fast-Path-Blue-快速路径" class="headerlink" title="Color Compositing Fast-Path Blue (快速路径)"></a>Color Compositing Fast-Path Blue (快速路径)</h2><p>&emsp;&emsp;标记由硬件绘制的路径为蓝色，蓝色越多越好.</p>
<h2 id="Flash-Updated-Regions-重绘区域"><a href="#Flash-Updated-Regions-重绘区域" class="headerlink" title="Flash Updated Regions (重绘区域)"></a>Flash Updated Regions (重绘区域)</h2><p>&emsp;&emsp;这个选项会对重绘的内容高亮成黄色,重绘就是指使用Core Graphics绘制，绘制会损耗一定的性能，因此重绘区域应该越小越好，对于未发生变化的内容则不应该重绘。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS--离屏渲染带来的性能问题和解决办法]]></title>
      <url>https://chirenhua.github.io/2016/10/22/iOS-%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="什么是离屏渲染"><a href="#什么是离屏渲染" class="headerlink" title="什么是离屏渲染"></a>什么是离屏渲染</h2><p>&emsp;&emsp;离屏渲染（Off-Screen Rendering）指的是在GPU在执行图层的合成时，会在当前屏幕的缓冲区外创建一个新的缓冲区去执行此操作，这样的话当GPU进行图层渲染时，都会先将图层移到屏幕外的缓冲区去执行合成操作，然后在移回当前屏幕的缓冲区进行渲染，由于这种转换会发生在渲染的每一帧，所以如果当前屏幕如果有大量的图层需要执行离屏渲染操作时，那就会造成严重的性能问题，产生卡顿。其实离屏渲染是为了优化而生，只不过错误的使用才会导致卡顿的产生。  </p>
<h2 id="什么操作会产生离屏渲染"><a href="#什么操作会产生离屏渲染" class="headerlink" title="什么操作会产生离屏渲染"></a>什么操作会产生离屏渲染</h2><p>&emsp;&emsp;以下操在使用不当时可能会触发离屏渲染：  </p>
<p>&emsp;&emsp;1. shouldRasterize（光栅化）<br>&emsp;&emsp;2. masks（遮罩）<br>&emsp;&emsp;3. shadows（阴影）<br>&emsp;&emsp;4. edge antialiasing（抗锯齿）<br>&emsp;&emsp;5. group opacity（不透明）  </p>
<p>&emsp;&emsp;以设置圆角为例，通常我们设置圆角的方法很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.layer.cornerRadius = 5;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;只需要一行代码就可以轻松的设置圆角，效果如下图：<br><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/iOS--%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/iOS--%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%9501.png" alt="image01"><br>&emsp;&emsp;但是如果我们在当前view上又覆盖多个view，那么如果覆盖的view超出了圆角的范围，那么圆角的设置就失效了，为了避免这种情况的发生，我们可以为其加上一个属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">view.layer.masksToBounds = YES;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;执行代码，发现所有的子view都已经被设置了圆角，效果如下图：<br><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/iOS--%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/iOS--%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%9502.png" alt="image02"></p>
<p>&emsp;&emsp;图片层次图：<br><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/iOS--%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/iOS--%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%9503.png" alt="image03"><br>&emsp;&emsp;看起来很完美，但是这个时候已经出发了离屏渲染，如果这个view足够多的话，就会造成非常明显的卡顿现象。  </p>
<h2 id="如何避免触发离屏渲染"><a href="#如何避免触发离屏渲染" class="headerlink" title="如何避免触发离屏渲染"></a>如何避免触发离屏渲染</h2><p>&emsp;&emsp;还是以设置圆角为例，目前来看优化的方式有两种：</p>
<h3 id="1-静态内容视图"><a href="#1-静态内容视图" class="headerlink" title="1.静态内容视图"></a>1.静态内容视图</h3><p>&emsp;&emsp;对于静态的视图，由于其内部结构和内容不会发生改变，所以可以通过设置“Rasterization”属性的方式来优化性能。</p>
<h3 id="2-动态内容视图"><a href="#2-动态内容视图" class="headerlink" title="2.动态内容视图"></a>2.动态内容视图</h3><p>&emsp;&emsp;对于动态的视图，现在主流的解决方案是在view的最外层盖上一个圆角的遮罩，来达到设置圆角的目的，如下图：<br><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/iOS--%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/iOS--%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%9504.png" alt="image04"><br>&emsp;&emsp;这种方法简单粗暴，而且效果非常好，但是缺点就是对背景颜色有要求，因为是在view的最外层覆盖了一个圆角view，所以就要求圆角view的颜色必须和当前视图所在view的背景颜色一致，如果背景颜色是动态改变或者不是纯色背景，那就不适合这种方法。<br>&emsp;&emsp;下面给出一个生成圆角遮罩图的方法：  </p>
<p><pre>- (UIImage <em> ) drawRoundedCornerImageWithRadius:(CGFloat)radius Rectsize:(CGSize)rectSize BackgroundColor:(UIColor</em> ) backgroundColor {<br>    UIGraphicsBeginImageContextWithOptions(rectSize, NO, [UIScreen mainScreen].scale);<br>    CGContextRef currentContext = UIGraphicsGetCurrentContext();<br>    UIBezierPath <em>bezierPath = [[UIBezierPath alloc]init];<br>    CGPoint hLeftUpPoint = CGPointMake(radius, 0);<br>    CGPoint hRightUpPoint = CGPointMake(rectSize.width - radius, 0);<br>    CGPoint hLeftDownPoint = CGPointMake(radius, rectSize.height);<br>    CGPoint vLeftUpPoint = CGPointMake(0, radius);<br>    CGPoint vRightDownPoint = CGPointMake(rectSize.width, rectSize.height - radius);<br>    CGPoint centerLeftUp = CGPointMake(radius, radius);<br>    CGPoint centerRightUp = CGPointMake(rectSize.width - radius, radius);<br>    CGPoint centerLeftDown = CGPointMake(radius, rectSize.height - radius);<br>    CGPoint centerRightDown = CGPointMake(rectSize.width - radius, rectSize.height - radius);<br>    [bezierPath moveToPoint:hLeftUpPoint];<br>    [bezierPath addLineToPoint:hRightUpPoint];<br>    [bezierPath addArcWithCenter:centerRightUp radius:radius startAngle:M_PI </em> 3 / 2 endAngle:M_PI <em> 2 clockwise:true];<br>    [bezierPath addLineToPoint:vRightDownPoint];<br>    [bezierPath addArcWithCenter:centerRightDown radius:radius startAngle:0 endAngle:M_PI / 2 clockwise:true];<br>    [bezierPath addLineToPoint:hLeftDownPoint];<br>    [bezierPath addArcWithCenter:centerLeftDown radius:radius startAngle:M_PI / 2 endAngle:M_PI clockwise:true];<br>    [bezierPath addLineToPoint:vLeftUpPoint];<br>    [bezierPath addArcWithCenter:centerLeftUp radius:radius startAngle:M_PI endAngle:M_PI </em> 3 / 2 clockwise:true];<br>    [bezierPath addLineToPoint:hLeftUpPoint];<br>    [bezierPath closePath];<br>    [bezierPath moveToPoint:CGPointZero];<br>    [bezierPath addLineToPoint:CGPointMake(0, rectSize.height)];<br>    [bezierPath addLineToPoint:CGPointMake(rectSize.width, rectSize.height)];<br>    [bezierPath addLineToPoint:CGPointMake(rectSize.width, 0)];<br>    [bezierPath moveToPoint:CGPointZero];<br>    [bezierPath closePath];<br>    [backgroundColor setFill];<br>    [bezierPath fill];<br>    CGContextDrawPath(currentContext, kCGPathFillStroke);<br>    UIImage * antiRoundedCornerImage = UIGraphicsGetImageFromCurrentImageContext();<br>    UIGraphicsEndImageContext();<br>    return antiRoundedCornerImage;<br>}</pre>  </p>
<h2 id="再优化"><a href="#再优化" class="headerlink" title="再优化"></a>再优化</h2><p>&emsp;&emsp;覆盖一个圆角view已经可以非常完美的应付绝大多数情况的离屏渲染，但是每个view在生成的时候都要去调用一遍生成圆角的方法去重新绘制一个圆角view，也是一种性能的浪费，所以可以在这个基础上对画好的圆角view做一个缓存，如果后续的view需要一样的圆角view那就不需要重新绘制，只需要去内存中取已经画好的圆角view就可以了。  </p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="http://www.jianshu.com/p/ca51c9d3575b" target="_blank" rel="external">离屏渲染优化详解：实例示范+性能测试</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS--NSUserDefaults用法总结]]></title>
      <url>https://chirenhua.github.io/2016/09/16/iOS-NSUserDefaults%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="NSUserDefaults原理"><a href="#NSUserDefaults原理" class="headerlink" title="NSUserDefaults原理"></a>NSUserDefaults原理</h2><p>&emsp;&emsp;NSUserDefaults是iOS为我们提供的一种轻量级的本地存储方式，其工作原理非常简单，就是将数据存储到本地的plist文件中。其实建立plist文件我们自己也可以完成，只不过自己去操作文件的创建、读取等会比较麻烦，使用“NSUserDefaults”则可以完全省略掉这些步骤，只需要进行简单的读写就可以了。</p>
<h2 id="NSUserDefaults支持的数据类型"><a href="#NSUserDefaults支持的数据类型" class="headerlink" title="NSUserDefaults支持的数据类型"></a>NSUserDefaults支持的数据类型</h2><p>&emsp;&emsp;因为NSUserDefaults是创建的plist类型的文件，所以它支持的数据类型也必须是plist文件能够存储的数据类型，分别是：<strong>NSNumber（NSInteger、float、double），NSString，NSDate，NSArray，NSDictionary，BOOL</strong>。需要注意的是，就算是存储的对象是“NSArray”类型的，那也要保证“NSArray”中存储的数据必须是plist文件支持的类型。如果需要存储plist不支持的数据类型，比如说一张图片或者一个自定义对象（下文会提到），可以先将其归档为“NSDate”类型，在存储到plist文件中。</p>
<h2 id="NSUserDefaults用法"><a href="#NSUserDefaults用法" class="headerlink" title="NSUserDefaults用法"></a>NSUserDefaults用法</h2><p>&emsp;&emsp;NSUserDefaults是一个单例，我们可以在程序的任何地方获取到它的唯一实例化对象：</p>
<pre>NSUserDefaults *userDefault = [NSUserDefaults standardUserDefaults];</pre>  
&emsp;&emsp;存储一个数据：  
<pre>[userDefault setObject:@"测试" forKey:@"test"];</pre>  
&emsp;&emsp;由于NSUserDefaults是隔一段时间将数据写到本地，所以为了保险起见，建议加上下面的代码，确保数据及时的存储。  
<pre>[userDefault synchronize];</pre>  
&emsp;&emsp;取出一个数据也是非常的简单：  
<pre>NSString *str = [userDefault objectForKey:@"test"];</pre>

<h2 id="使用NSUserDefaults存储自定义对象"><a href="#使用NSUserDefaults存储自定义对象" class="headerlink" title="使用NSUserDefaults存储自定义对象"></a>使用NSUserDefaults存储自定义对象</h2><h3 id="1-将自定义类型转换为NSDate类型"><a href="#1-将自定义类型转换为NSDate类型" class="headerlink" title="1.将自定义类型转换为NSDate类型"></a>1.将自定义类型转换为NSDate类型</h3><p>&emsp;&emsp;其实不建议将数据这样存储，多数据复杂类型还是建议存到数据库中，如果非要这样存储的话，可以先将自定义类型归档为NSDate类型，因为plist文件是支持存储NSDate类型数据的，然后再通过NSUserDefaults进行存储。下面举个例子：<br>&emsp;&emsp;假如我们要把书籍的对象存储起来。首先要在“.h”文件中声明“NSCoding”协议，并在“.m”文件中实现“encodeWithCoder”和“initWithCoder”两个方法。<br>&emsp;&emsp;.h文件：</p>
<pre>//
//  Book.h
//  Book
//
//  Created by Renhuachi on 16/3/22.
//  Copyright © 2016年 software. All rights reserved.
//

＃import < Foundation/Foundation.h >

@interface Book : NSObject <nscoding>
＃pragma mark - 属性
@property (nonatomic,copy) NSString *authorName;
@property (nonatomic,copy) NSString *bookName;

@end</nscoding></pre>  
&emsp;&emsp;.m文件  
<pre>//
//  Book.m
//  Book
//
//  Created by Renhuachi on 16/3/22.
//  Copyright © 2016年 software. All rights reserved.
//

＃import "Book.h"

@implementation Book

- (id)initWithCoder:(NSCoder *)aDecoder {
    if (self = [super init]) {
        _authorName = [aDecoder decodeObjectForKey:@"authorName"];
        _bookName = [aDecoder decodeObjectForKey:@"bookName"];
    }
    return self;
}

- (void)encodeWithCoder:(NSCoder *)aCoder {
    [aCoder encodeObject:_authorName forKey:@"authorName"];
    [aCoder encodeObject:_bookName forKey:@"bookName"];
}
@end</pre>

<h3 id="2-利用NSUserDefaults存储自定义类"><a href="#2-利用NSUserDefaults存储自定义类" class="headerlink" title="2.利用NSUserDefaults存储自定义类"></a>2.利用NSUserDefaults存储自定义类</h3><p>&emsp;&emsp;首先创建一个Book类型的对象，并将其归档为NSDate类型，然后存储到NSUserDefaults中。  </p>
<pre>Book *book = [[Book alloc]init];
book.authorName = @"书名";
book.bookName = @"作者";

NSData *data = [NSKeyedArchiver archivedDataWithRootObject:book];
NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
[userDefaults setObject:data forKey:@"book"];</pre>  
&emsp;&emsp;从NSUserDefaults中还原数据也很简单。  
<pre>NSUserDefaults *user = [NSUserDefaults standardUserDefaults];
NSdData *data = [user objectForKey:@"book"];  
Book *book = [NSKeyedUnarchiver unarchiveObjectWithData:data];</pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS--使用UISearchController创建搜索框]]></title>
      <url>https://chirenhua.github.io/2016/08/29/iOS-%E4%BD%BF%E7%94%A8UISearchController%E5%88%9B%E5%BB%BA%E6%90%9C%E7%B4%A2%E6%A1%86/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;在iOS8之前，我们一直利用UISearchBar和UISearchDisplayController来实现搜索框，但是在iOS8以后上述方法已经过时，改而实用UISearchController来替代，用起来比之前的方法要简单好多。  </p>
<h2 id="添加UISearchController变量"><a href="#添加UISearchController变量" class="headerlink" title="添加UISearchController变量"></a>添加UISearchController变量</h2><p>&emsp;&emsp;在开始之前我们要添加UISearchController变量，并未搜索前的数据和搜索结果创建两个数组：  </p>
<p><pre>@property(strong, nonatomic) UISearchController <em>searchController;<br>@property(strong, nonatomic) NSMutableArray </em>bookArray;<br>@property(strong, nonatomic) NSMutableArray *bookResult;</pre></p>
<h2 id="初始化UISearchController"><a href="#初始化UISearchController" class="headerlink" title="初始化UISearchController"></a>初始化UISearchController</h2><p>&emsp;&emsp;初始化UISearchController并设置其属性和默认文字  </p>
<pre>- (void)showSearchBar {
    _searchController = [[UISearchController alloc] initWithSearchResultsController:nil];
    //搜索结果处理函数代理
    _searchController.searchResultsUpdater = self;
    //是否显示背景
    _searchController.dimsBackgroundDuringPresentation = false;
    [_searchController.searchBar sizeToFit];
    //修改searchBar的默认文字
    _searchController.searchBar.placeholder = @"搜索";
    //修改“Cancle按钮的默认文字”
    [_searchController.searchBar setValue:@"取消" forKey:@"_cancelButtonText"];
    //将搜索框添加到tableHeaderView中
    _CheckBookViewtableView.tableHeaderView = self.searchController.searchBar;
}</pre>

<h2 id="添加UISearchResultsUpdating协议"><a href="#添加UISearchResultsUpdating协议" class="headerlink" title="添加UISearchResultsUpdating协议"></a>添加UISearchResultsUpdating协议</h2><p>&emsp;&emsp;如果要对搜索结果进行处理，那我们要为UISearchController添加一个搜索结果处理的协议，并实现其下的方法：<br>&emsp;&emsp;添加协议：</p>
<p><pre>@interface CheckBookViewController ()&lt; UITableViewDataSource,UITableViewDelegate,UISearchResultsUpdating &gt;</pre></p>
<p>&emsp;&emsp;实现方法：</p>
<pre>- (void)updateSearchResultsForSearchController:(UISearchController *)searchController {
    [searchResult removeAllObjects];
    NSString *keyWord = [searchController .searchBar text];
    [bookArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        Book *book = obj;
        if ([book.bookName.uppercaseString containsString:keyWord.uppercaseString]) {
            [searchResult addObject:book];
        }
    }];
    [_CheckBookViewtableView reloadData];
}</pre>

<h2 id="UITableView代理方法下对搜索结果的处理"><a href="#UITableView代理方法下对搜索结果的处理" class="headerlink" title="UITableView代理方法下对搜索结果的处理"></a>UITableView代理方法下对搜索结果的处理</h2><p>&emsp;&emsp;因为搜索结果要复用界面的TableView，所以在TableView的代理方法下要进行判断当前是搜索的界面还是主界面：</p>
<pre>- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    // 判断是否是搜索结果的tableView
    if ([self.searchController isActive]) {
        return searchResult.count;
    }
    return [bookArray count];
}
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    Book *books;
    CheckBookViewcell = [tableView dequeueReusableCellWithIdentifier:@"UIListTableViewCell"];                                                        // 从缓存池中取出cell
    if (!CheckBookViewcell) {                                                                                                                        // 判断是否能取出cell
        CheckBookViewcell = [[ListTableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@"UIListTableViewCell"];            // 如果cell为空则创建一个新的cell并放入缓存池中
    }else{                                                                                                                                           // 如果cell不为空（注意：以下操作很重要，不然会造成cell数据错乱）
        [CheckBookViewcell removeCellView];                                                                                                          // 将之前cell界面上的view全部remove掉
        [CheckBookViewcell initCellView];                                                                                                            // 重新初始化cell上的view
    }
    // 判断是否是搜索结果的tableView
    if ([self.searchController isActive]) {
        books = searchResult[indexPath.row];
    }else {
        if (viewcode) {
            books = bookArray[indexPath.row];
        }else {
            books = bookArray[indexPath.row];
        }
    }

    [CheckBookViewcell setBookInfo:books];
    return CheckBookViewcell;
}
- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {
    Book *book;
    if ([_searchController isActive]) {
        book = searchResult[indexPath.row];
    }else {
        book = bookArray[indexPath.row];
    }
    BookDetialViewController *bookDetialVC = [[BookDetialViewController alloc]init:book];
    [self.navigationController pushViewController:bookDetialVC animated:YES];
    [tableView deselectRowAtIndexPath:indexPath animated:YES];                                                                                  // 取消选中的状态
}</pre>

<h2 id="最后注意"><a href="#最后注意" class="headerlink" title="最后注意!"></a>最后注意!</h2><p>&emsp;&emsp;在离开界面时要销毁掉UISearchController，不然它会在其它界面一直存在：</p>
<pre>- (void)viewWillDisappear:(BOOL)animated {
    [super viewWillDisappear:animated];
    if (self.searchController.active) {
        self.searchController.active = NO;
        [self.searchController.searchBar removeFromSuperview];
    }
}</pre>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[安装CocoaPods过程以及踩过的坑]]></title>
      <url>https://chirenhua.github.io/2016/08/27/%E5%AE%89%E8%A3%85CocoaPods%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/</url>
      <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/安装CocoaPods过程以及踩过的坑/cocoapods-stickers.jpg" alt="cocoaPods logo">  </p>
<h2 id="为什么要用到CocoaPods"><a href="#为什么要用到CocoaPods" class="headerlink" title="为什么要用到CocoaPods"></a>为什么要用到CocoaPods</h2><p>&emsp;&emsp;以往在写iOS程序的时候，遇到好的第三方开源库都是将开源库下载下来，拷贝到项目中，然后再去使用，而且遇到开源库更新，我们还要重新执行一边操作。如果开源库数量很多，这个操作就显得非常麻烦了。<br>&emsp;&emsp;现在有了CocoaPods，这些问题就都迎刃而解了，CocoaPods可以帮助我们下载，管理第三方的开源库，包括更新、系统依赖和编译参数等都能帮助我们处理。简直不能再方便，设置完CocoaPods后，以后我们只需要专心的敲代码就好了。  </p>
<h2 id="CocoaPods的原理"><a href="#CocoaPods的原理" class="headerlink" title="CocoaPods的原理"></a>CocoaPods的原理</h2><p>&emsp;&emsp;CocoaPods是将所有的依赖库放到另一个名为Pods的项目中，然后让主项目依赖Pods项目，这样，源码管理工作都从主项目移到了Pods项目中。Pods项目最终会编译成一个名为libPods.a的文件，主项目只需要依赖这个.a文件即可。</p>
<h2 id="安装CocoaPods"><a href="#安装CocoaPods" class="headerlink" title="安装CocoaPods"></a>安装CocoaPods</h2><p>&emsp;&emsp;现在Mac上似乎已经自带了Ruby，如果没有的话可以通过“<a href="http://www.cnblogs.com/daguo/p/4097263.html" target="_blank" rel="external">如何在Mac OS X上安装 Ruby运行环境</a>”这篇文章来安装。安装完ruby后，打开Terminal终端，输入以下命令：<br>&emsp;&emsp;<code>$ sudo gem install cocoapods</code>（注意：在执行这条命令前请保证你的gem为最新版）<br>&emsp;&emsp;然后执行安装操作，输入命令：<br>&emsp;&emsp;<code>$ pod setup</code><br>&emsp;&emsp;此时Terminal终端会停留在“Setting up CocoaPods master repo”这个状态一段时间，因为这个时候是在下载安装开源库的文件，安装时间的长短由你的网速等决定。注意，在这里是一个很大的坑，我在这里折腾了一整天，最后才弄好。为了节省大家时间我直接说我的解决办法。<br>&emsp;&emsp;如果你也是用了很多办法都下不来安装文件，或者下载一会儿就报错要重下的话，那么可以参考下这个办法：<br>&emsp;&emsp;1. 访问 <a href="https://github.com/CocoaPods/Specs" target="_blank" rel="external">https://github.com/CocoaPods/Specs</a>，然后将Specs项目fork到自己的github账户上。<br>&emsp;&emsp;2. 下载GitHub Desktop, 然后clone Specs项目。<br>&emsp;&emsp;3. 将clone的Specs项目的文件夹改名为master，然后拖到/Users/用户名/.cocoapods/repos目录下。<br>&emsp;&emsp;4. 运行pod setup<br>&emsp;&emsp;pod setup的本质就是将<a href="https://github.com/CocoaPods/Specs" target="_blank" rel="external">https://github.com/CocoaPods/Specs</a>上的Specs项目clone到/Users/用户名/.cocoapods/repos目录下。若此目录下已有Specs项目，则会将项目更新到最新的状态。由于Specs很大，容易导致pod setup失败。这时就需要我们手动安装Specs。若直接从github上下载zip文件，由于缺少git文件，会导致cocoa pods不使用。若用git clone，由于文件过大，容易导致失败。但是使用GitHub Desktop软件，则会提高clone的成功率，并且会给出clone的进度，但是我也是下了三遍最后才clone下来。</p>
<h2 id="使用CocoaPods"><a href="#使用CocoaPods" class="headerlink" title="使用CocoaPods"></a>使用CocoaPods</h2><p>&emsp;&emsp;废了好大劲安装完毕后，就是如何使用了，举个栗子：假如说我们要在项目中导入非常火的“AFNetworking”类库，我们先要确定AFNetworking是否支持CocoaPods，所以我们先利用CocoaPods的搜索功能搜索下，在Terminal终端上输入以下命令：<br>&emsp;&emsp;<code>$ pod search AFNetworking</code><br>&emsp;&emsp;如果出现错误：“[!] Unable to find a pod with name, author, summary, or description matching AFNetworking”，可以通过执行下面的命令来解决：<br>&emsp;&emsp;<code>rm ~/Library/Caches/CocoaPods/search_index.json</code><br>&emsp;&emsp;如果执行成功，会出现“AFNetworking”的相关信息，如下图。<br><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/安装CocoaPods过程以及踩过的坑/searchResult.png" alt="searchResult"><br>&emsp;&emsp;这说明“AFNetworking”是支持CocoaPods的。接下来我们就可以将“AFNetworking”导入到我们的项目中去。<br>&emsp;&emsp;首先，我们通过Terminal终端进入到们已经创建好的项目目录下，执行下面的命令：<br>&emsp;&emsp;<code>$ vim Podfile</code><br>&emsp;&emsp;这个命令的作用是在项目目录下生成一个名为“Podfile”的文件，这个文件的作用就是用来告诉CocoaPods需要下什么类库，然后我们在Podfile文件中添加以下文字：（注意：不要用文本编辑器进行编辑！）  </p>
<p><pre>&emsp;&emsp;platform :ios, ‘9.0’<br>&emsp;&emsp;&emsp;&emsp;target ‘MyApp’ do<br>&emsp;&emsp;&emsp;&emsp;pod ‘AFNetworking’, ‘~&gt; 3.1’<br>&emsp;&emsp;end</pre><br>&emsp;&emsp;然后保存退出，这时候在项目的目录里就会出现一个名为Podfile的文件，然后我们执行以下命令来将“AFNetworking”下载到项目中。（注意：下面的命令需要在项目目录中执行。）<br>&emsp;&emsp;<code>$ pod install</code><br>&emsp;&emsp;执行成功后，项目中会多出来一个.xcworkspace类型的文件，如下图：<br><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/安装CocoaPods过程以及踩过的坑/project.png" alt="project"><br>&emsp;&emsp;以后需要用它来打开工程才会配置类库的相关文件。<br>&emsp;&emsp;以上就是CocoaPods的安装和使用方法介绍，如果想要了解更多的使用方法，可以参考<a href="https://github.com/CocoaPods/CocoaPods/wiki" target="_blank" rel="external">官方文档</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo常用命令整理]]></title>
      <url>https://chirenhua.github.io/2016/08/27/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/Hexo常用命令整理/hexo.jpg" alt="Hexo logl">  </p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装<br><code>npm install hexo -g</code><br>升级<br><code>npm update hexo -g</code><br>初始化<br><code>hexo init</code></p>
<h2 id="发表文章"><a href="#发表文章" class="headerlink" title="发表文章"></a>发表文章</h2><p>新建文章<br><code>hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot;</code><br>发表草稿<br><code>hexo p == hexo publish</code><br>生成静态文件<br><code>hexo g == hexo generate</code><br>启动服务预览<br><code>hexo s == hexo server</code><br>部署到远程<br><code>hexo d == hexo deploy</code></p>
<h2 id="清理缓存"><a href="#清理缓存" class="headerlink" title="清理缓存"></a>清理缓存</h2><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)<br><code>hexo clean</code></p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>查看Hexo运行版本<br><code>hexo version</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>https://chirenhua.github.io/2016/08/24/hello-world/</url>
      <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/Hello%20world/home-bg-o.jpg" alt="hello world"><br>&emsp;&emsp;作为一个程序员，“Hello World”可以说为我打开了新世界的大门。第一个程序，第一个网站，第一个脚本…都是从“Hello World”开始的。因为我已经决定要重新开启我的博客生涯，所以我的第一篇博文就叫“Hello World”！</p>
<p>&emsp;&emsp;人这一辈子最开心的事莫过于做自己喜欢的事情，很幸运，我的工作也是我的爱好，这也是支撑着我在周末来公司加班写博客的动力哈哈哈。</p>
<p>&emsp;&emsp;我觉得编程就像画画一样，键盘是画笔，代码是墨，编译器是画纸。我们在键盘上敲敲敲，就像拿着笔在纸上挥毫一样，最终我们都会创造出一个个无法复刻的作品。所以说编程是门艺术，一点都没错。</p>
<p>&emsp;&emsp;第一篇博客就不写太多，我要去创造我的艺术品啦～</p>
<p>&emsp;&emsp;“Hello World”！</p>
]]></content>
    </entry>
    
  
  
</search>
