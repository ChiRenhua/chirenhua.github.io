<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[iOS--使用UISearchController创建搜索框]]></title>
      <url>https://chirenhua.github.io/2016/08/29/iOS-%E4%BD%BF%E7%94%A8UISearchController%E5%88%9B%E5%BB%BA%E6%90%9C%E7%B4%A2%E6%A1%86/</url>
      <content type="html"><![CDATA[<p>&emsp;&emsp;在iOS8之前，我们一直利用UISearchBar和UISearchDisplayController来实现搜索框，但是在iOS8以后上述方法已经过时，改而实用UISearchController来替代，用起来比之前的方法要简单好多。  </p>
<h2 id="添加UISearchController变量"><a href="#添加UISearchController变量" class="headerlink" title="添加UISearchController变量"></a>添加UISearchController变量</h2><p>&emsp;&emsp;在开始之前我们要添加UISearchController变量，并未搜索前的数据和搜索结果创建两个数组：  </p>
<p><pre>@property(strong, nonatomic) UISearchController <em>searchController;<br>@property(strong, nonatomic) NSMutableArray </em>bookArray;<br>@property(strong, nonatomic) NSMutableArray *bookResult;</pre></p>
<h2 id="初始化UISearchController"><a href="#初始化UISearchController" class="headerlink" title="初始化UISearchController"></a>初始化UISearchController</h2><p>&emsp;&emsp;初始化UISearchController并设置其属性和默认文字  </p>
<pre>- (void)showSearchBar {
    _searchController = [[UISearchController alloc] initWithSearchResultsController:nil];
    //搜索结果处理函数代理
    _searchController.searchResultsUpdater = self;
    //是否显示背景
    _searchController.dimsBackgroundDuringPresentation = false;
    [_searchController.searchBar sizeToFit];
    //修改searchBar的默认文字
    _searchController.searchBar.placeholder = @"搜索";
    //修改“Cancle按钮的默认文字”
    [_searchController.searchBar setValue:@"取消" forKey:@"_cancelButtonText"];
    //将搜索框添加到tableHeaderView中
    _CheckBookViewtableView.tableHeaderView = self.searchController.searchBar;
}</pre>

<h2 id="添加UISearchResultsUpdating协议"><a href="#添加UISearchResultsUpdating协议" class="headerlink" title="添加UISearchResultsUpdating协议"></a>添加UISearchResultsUpdating协议</h2><p>&emsp;&emsp;如果要对搜索结果进行处理，那我们要为UISearchController添加一个搜索结果处理的协议，并实现其下的方法：<br>&emsp;&emsp;添加协议：</p>
<p><pre>@interface CheckBookViewController ()&lt; UITableViewDataSource,UITableViewDelegate,UISearchResultsUpdating &gt;</pre></p>
<p>&emsp;&emsp;实现方法：</p>
<pre>- (void)updateSearchResultsForSearchController:(UISearchController *)searchController {
    [searchResult removeAllObjects];
    NSString *keyWord = [searchController .searchBar text];
    [bookArray enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        Book *book = obj;
        if ([book.bookName.uppercaseString containsString:keyWord.uppercaseString]) {
            [searchResult addObject:book];
        }
    }];
    [_CheckBookViewtableView reloadData];
}</pre>

<h2 id="UITableView代理方法下对搜索结果的处理"><a href="#UITableView代理方法下对搜索结果的处理" class="headerlink" title="UITableView代理方法下对搜索结果的处理"></a>UITableView代理方法下对搜索结果的处理</h2><p>&emsp;&emsp;因为搜索结果要复用界面的TableView，所以在TableView的代理方法下要进行判断当前是搜索的界面还是主界面：</p>
<pre>- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    // 判断是否是搜索结果的tableView
    if ([self.searchController isActive]) {
        return searchResult.count;
    }
    return [bookArray count];
}
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
    Book *books;
    CheckBookViewcell = [tableView dequeueReusableCellWithIdentifier:@"UIListTableViewCell"];                                                        // 从缓存池中取出cell
    if (!CheckBookViewcell) {                                                                                                                        // 判断是否能取出cell
        CheckBookViewcell = [[ListTableViewCell alloc]initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:@"UIListTableViewCell"];            // 如果cell为空则创建一个新的cell并放入缓存池中
    }else{                                                                                                                                           // 如果cell不为空（注意：以下操作很重要，不然会造成cell数据错乱）
        [CheckBookViewcell removeCellView];                                                                                                          // 将之前cell界面上的view全部remove掉
        [CheckBookViewcell initCellView];                                                                                                            // 重新初始化cell上的view
    }
    // 判断是否是搜索结果的tableView
    if ([self.searchController isActive]) {
        books = searchResult[indexPath.row];
    }else {
        if (viewcode) {
            books = bookArray[indexPath.row];
        }else {
            books = bookArray[indexPath.row];
        }
    }

    [CheckBookViewcell setBookInfo:books];
    return CheckBookViewcell;
}
- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {
    Book *book;
    if ([_searchController isActive]) {
        book = searchResult[indexPath.row];
    }else {
        book = bookArray[indexPath.row];
    }
    BookDetialViewController *bookDetialVC = [[BookDetialViewController alloc]init:book];
    [self.navigationController pushViewController:bookDetialVC animated:YES];
    [tableView deselectRowAtIndexPath:indexPath animated:YES];                                                                                  // 取消选中的状态
}</pre>

<h2 id="最后注意"><a href="#最后注意" class="headerlink" title="最后注意!"></a>最后注意!</h2><p>&emsp;&emsp;在离开界面时要销毁掉UISearchController，不然它会在其它界面一直存在：</p>
<pre>- (void)viewWillDisappear:(BOOL)animated {
    [super viewWillDisappear:animated];
    if (self.searchController.active) {
        self.searchController.active = NO;
        [self.searchController.searchBar removeFromSuperview];
    }
}</pre>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[安装CocoaPods过程以及踩过的坑]]></title>
      <url>https://chirenhua.github.io/2016/08/27/%E5%AE%89%E8%A3%85CocoaPods%E8%BF%87%E7%A8%8B%E4%BB%A5%E5%8F%8A%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/</url>
      <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/安装CocoaPods过程以及踩过的坑/cocoapods-stickers.jpg" alt="cocoaPods logo">  </p>
<h2 id="为什么要用到CocoaPods"><a href="#为什么要用到CocoaPods" class="headerlink" title="为什么要用到CocoaPods"></a>为什么要用到CocoaPods</h2><p>&emsp;&emsp;以往在写iOS程序的时候，遇到好的第三方开源库都是将开源库下载下来，拷贝到项目中，然后再去使用，而且遇到开源库更新，我们还要重新执行一边操作。如果开源库数量很多，这个操作就显得非常麻烦了。<br>&emsp;&emsp;现在有了CocoaPods，这些问题就都迎刃而解了，CocoaPods可以帮助我们下载，管理第三方的开源库，包括更新、系统依赖和编译参数等都能帮助我们处理。简直不能再方便，设置完CocoaPods后，以后我们只需要专心的敲代码就好了。  </p>
<h2 id="CocoaPods的原理"><a href="#CocoaPods的原理" class="headerlink" title="CocoaPods的原理"></a>CocoaPods的原理</h2><p>&emsp;&emsp;CocoaPods是将所有的依赖库放到另一个名为Pods的项目中，然后让主项目依赖Pods项目，这样，源码管理工作都从主项目移到了Pods项目中。Pods项目最终会编译成一个名为libPods.a的文件，主项目只需要依赖这个.a文件即可。</p>
<h2 id="安装CocoaPods"><a href="#安装CocoaPods" class="headerlink" title="安装CocoaPods"></a>安装CocoaPods</h2><p>&emsp;&emsp;现在Mac上似乎已经自带了Ruby，如果没有的话可以通过“<a href="http://www.cnblogs.com/daguo/p/4097263.html" target="_blank" rel="external">如何在Mac OS X上安装 Ruby运行环境</a>”这篇文章来安装。安装完ruby后，打开Terminal终端，输入以下命令：<br>&emsp;&emsp;<code>$ sudo gem install cocoapods</code>（注意：在执行这条命令前请保证你的gem为最新版）<br>&emsp;&emsp;然后执行安装操作，输入命令：<br>&emsp;&emsp;<code>$ pod setup</code><br>&emsp;&emsp;此时Terminal终端会停留在“Setting up CocoaPods master repo”这个状态一段时间，因为这个时候是在下载安装开源库的文件，安装时间的长短由你的网速等决定。注意，在这里是一个很大的坑，我在这里折腾了一整天，最后才弄好。为了节省大家时间我直接说我的解决办法。<br>&emsp;&emsp;如果你也是用了很多办法都下不来安装文件，或者下载一会儿就报错要重下的话，那么可以参考下这个办法：<br>&emsp;&emsp;1. 访问 <a href="https://github.com/CocoaPods/Specs" target="_blank" rel="external">https://github.com/CocoaPods/Specs</a>，然后将Specs项目fork到自己的github账户上。<br>&emsp;&emsp;2. 下载GitHub Desktop, 然后clone Specs项目。<br>&emsp;&emsp;3. 将clone的Specs项目的文件夹改名为master，然后拖到/Users/用户名/.cocoapods/repos目录下。<br>&emsp;&emsp;4. 运行pod setup<br>&emsp;&emsp;pod setup的本质就是将<a href="https://github.com/CocoaPods/Specs" target="_blank" rel="external">https://github.com/CocoaPods/Specs</a>上的Specs项目clone到/Users/用户名/.cocoapods/repos目录下。若此目录下已有Specs项目，则会将项目更新到最新的状态。由于Specs很大，容易导致pod setup失败。这时就需要我们手动安装Specs。若直接从github上下载zip文件，由于缺少git文件，会导致cocoa pods不使用。若用git clone，由于文件过大，容易导致失败。但是使用GitHub Desktop软件，则会提高clone的成功率，并且会给出clone的进度，但是我也是下了三遍最后才clone下来。</p>
<h2 id="使用CocoaPods"><a href="#使用CocoaPods" class="headerlink" title="使用CocoaPods"></a>使用CocoaPods</h2><p>&emsp;&emsp;废了好大劲安装完毕后，就是如何使用了，举个栗子：假如说我们要在项目中导入非常火的“AFNetworking”类库，我们先要确定AFNetworking是否支持CocoaPods，所以我们先利用CocoaPods的搜索功能搜索下，在Terminal终端上输入以下命令：<br>&emsp;&emsp;<code>$ pod search AFNetworking</code><br>&emsp;&emsp;如果出现错误：“[!] Unable to find a pod with name, author, summary, or description matching AFNetworking”，可以通过执行下面的命令来解决：<br>&emsp;&emsp;<code>rm ~/Library/Caches/CocoaPods/search_index.json</code><br>&emsp;&emsp;如果执行成功，会出现“AFNetworking”的相关信息，如下图。<br><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/安装CocoaPods过程以及踩过的坑/searchResult.png" alt="searchResult"><br>&emsp;&emsp;这说明“AFNetworking”是支持CocoaPods的。接下来我们就可以将“AFNetworking”导入到我们的项目中去。<br>&emsp;&emsp;首先，我们通过Terminal终端进入到们已经创建好的项目目录下，执行下面的命令：<br>&emsp;&emsp;<code>$ vim Podfile</code><br>&emsp;&emsp;这个命令的作用是在项目目录下生成一个名为“Podfile”的文件，这个文件的作用就是用来告诉CocoaPods需要下什么类库，然后我们在Podfile文件中添加以下文字：（注意：不要用文本编辑器进行编辑！）  </p>
<p><pre>&emsp;&emsp;platform :ios, ‘9.0’<br>&emsp;&emsp;&emsp;&emsp;target ‘MyApp’ do<br>&emsp;&emsp;&emsp;&emsp;pod ‘AFNetworking’, ‘~&gt; 3.1’<br>&emsp;&emsp;end</pre><br>&emsp;&emsp;然后保存退出，这时候在项目的目录里就会出现一个名为Podfile的文件，然后我们执行以下命令来将“AFNetworking”下载到项目中。（注意：下面的命令需要在项目目录中执行。）<br>&emsp;&emsp;<code>$ pod install</code><br>&emsp;&emsp;执行成功后，项目中会多出来一个.xcworkspace类型的文件，如下图：<br><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/安装CocoaPods过程以及踩过的坑/project.png" alt="project"><br>&emsp;&emsp;以后需要用它来打开工程才会配置类库的相关文件。<br>&emsp;&emsp;以上就是CocoaPods的安装和使用方法介绍，如果想要了解更多的使用方法，可以参考<a href="https://github.com/CocoaPods/CocoaPods/wiki" target="_blank" rel="external">官方文档</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo常用命令整理]]></title>
      <url>https://chirenhua.github.io/2016/08/27/hexo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/Hexo常用命令整理/hexo.jpg" alt="Hexo logl">  </p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装<br><code>npm install hexo -g</code><br>升级<br><code>npm update hexo -g</code><br>初始化<br><code>hexo init</code></p>
<h2 id="发表文章"><a href="#发表文章" class="headerlink" title="发表文章"></a>发表文章</h2><p>新建文章<br><code>hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot;</code><br>发表草稿<br><code>hexo p == hexo publish</code><br>生成静态文件<br><code>hexo g == hexo generate</code><br>启动服务预览<br><code>hexo s == hexo server</code><br>部署到远程<br><code>hexo d == hexo deploy</code></p>
<h2 id="清理缓存"><a href="#清理缓存" class="headerlink" title="清理缓存"></a>清理缓存</h2><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)<br><code>hexo clean</code></p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>查看Hexo运行版本<br><code>hexo version</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>https://chirenhua.github.io/2016/08/24/hello-world/</url>
      <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/ChiRenhua/Resource/master/WebImage/Hello%20world/home-bg-o.jpg" alt="hello world"><br>&emsp;&emsp;作为一个程序员，“Hello World”可以说为我打开了新世界的大门。第一个程序，第一个网站，第一个脚本…都是从“Hello World”开始的。因为我已经决定要重新开启我的博客生涯，所以我的第一篇博文就叫“Hello World”！</p>
<p>&emsp;&emsp;人这一辈子最开心的事莫过于做自己喜欢的事情，很幸运，我的工作也是我的爱好，这也是支撑着我在周末来公司加班写博客的动力哈哈哈。</p>
<p>&emsp;&emsp;我觉得编程就像画画一样，键盘是画笔，代码是墨，编译器是画纸。我们在键盘上敲敲敲，就像拿着笔在纸上挥毫一样，最终我们都会创造出一个个无法复刻的作品。所以说编程是门艺术，一点都没错。</p>
<p>&emsp;&emsp;第一篇博客就不写太多，我要去创造我的艺术品啦～</p>
<p>&emsp;&emsp;“Hello World”！</p>
]]></content>
    </entry>
    
  
  
</search>
